%THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{hyperref}
\newtheorem{lemma}{Lemma}
\newtheorem{corr}{Corollary}
\newenvironment{hint}{\noindent{\bf (Hint)}}{}
\newtheorem{thm}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{task}{Task}
\newtheorem{bonus}{Bonus Task}

\newif\ifsol

\newcommand{\makehwtitle}[4]
{{\centering\Large\textbf{Homework #1: #2}
    \normalsize\\
15-814: Types and Programming Languages\\
Fall 2015\\
TA: Evan Cavallo (ecavallo@cs.cmu.edu)\\
\ifsol \solcolor \textbf{SOLUTIONS} \normalcolor \\ \fi \vspace{0.5cm}%
Out: #3\\
Due: #4\\
}}

\newenvironment{proof}{\trivlist \item[\hskip \labelsep{\bf
Proof:}]}{\hfill$\Box$ \endtrivlist}

\newenvironment{sol}{
\trivlist \item[\hskip \labelsep{\bf
Solution:}]}{\endtrivlist}

\newcommand{\solution}[1]{\ifsol \begin{sol} #1 \end{sol} \fi}

\newcommand{\taskpts}[1]{[#1]}

\newenvironment{includeintemplate}{}{}
\newenvironment{noinclude}{}{}
\newcommand{\rulename}[1]{\text{\textsc{(#1)}}}
\newcommand{\einfer}[3]
        {\begin{equation}\label{eq:#1}\infer[]{#2}{#3}\end{equation}}

\allowdisplaybreaks       %mildly permissible to break up displayed equations
% Problem 1

\newcommand{\defeq}{\overset{\mathsf{def}}{=}}

%%Expression language
%Sorts
\newcommand{\sort}{\mathsf}
\newcommand{\exps}{\sort{exp}}
\newcommand{\funs}{\sort{fun}}
\newcommand{\progs}{\sort{prog}}

%Syntax
\newcommand{\elangname}{\textbf{E}}
\newcommand{\opf}[1]{\mathtt{#1}}
\newcommand{\numt}{\opf{int}}
\newcommand{\boolt}{\opf{bool}}
\newcommand{\Arrt}[2]{#1 \Rightarrow #2}
\newcommand{\num}[1]{\opf{num}[#1]}
\newcommand{\etrue}{\opf{true}}
\newcommand{\efalse}{\opf{false}}
\newcommand{\eplus}[2]{\opf{plus}(#1; #2)}
\newcommand{\etimes}[2]{\opf{times}(#1; #2)}
\newcommand{\eleq}[2]{\opf{leq}(#1; #2)}
\newcommand{\eifb}[3]{\opf{if}(#1; #2; #3)}
\newcommand{\cifb}[3]{\opf{if}~#1~\opf{then}~#2~\opf{else}~#3}
\newcommand{\efun}[1]{\opf{fn}(#1)}
\newcommand{\eappe}[2]{{^*}#1(#2)}
\newcommand{\metacat}{\text{\textasciicircum}}

\newcommand{\pfun}[4]{\opf{fun}~#1~(#2 : #3)~\{ #4 \};}
\newcommand{\pres}[1]{\opf{result}~#1}
\newcommand{\pstruct}[2]{\opf{type}~#1 = #2;}

%Judgments
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}
\newcommand{\entails}{\vdash}
\newcommand{\etype}[2]{#1 :_{\mathsf{e}} #2}
\newcommand{\ftype}[3]{#1 :_{\mathsf{f}} \Arrt{#2}{#3}}
\newcommand{\ptype}[2]{#1 :_{\mathsf{p}} #2}
\newcommand{\fctx}[2]{#1 ::_{\mathsf{f}} #2}

\newcommand{\stepsto}{\mapsto}
\newcommand{\val}{\mathsf{val}}
\newcommand{\esteps}[2]{#1 \stepsto_{\mathsf{e}} #2}
\newcommand{\psteps}[2]{#1 \stepsto_{\mathsf{p}} #2}
\newcommand{\eval}[1]{#1\; \val_{\mathsf{e}}}
\newcommand{\pval}[1]{#1\; \val_{\mathsf{p}}}
\newcommand{\fundef}[3]{#1 \defeq #2.#3}

\newcommand{\varname}{\textit}

%Types
\newcommand{\unitt}{\mathtt{unit}}
\newcommand{\sumt}[2]{#1 + #2}
\newcommand{\prodt}[2]{#1 \times #2}

%Expressions
\newcommand{\inl}[1]{\mathtt{in}[l](#1)}
\newcommand{\inr}[1]{\mathtt{in}[r](#1)}
\newcommand{\ecase}[5]{\mathtt{case}\; #1\; \{#2. #3; #4. #5\}}
\newcommand{\eprod}[2]{\langle #1, #2 \rangle}
\newcommand{\triv}{\langle \rangle}
\newcommand{\projl}[1]{\mathtt{fst}\; #1}
\newcommand{\projr}[1]{\mathtt{snd}\; #1}
